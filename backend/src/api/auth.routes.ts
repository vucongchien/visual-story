// src/api/auth.routes.ts

import { Router } from 'express';
import { OAuth2Client, CodeChallengeMethod } from 'google-auth-library';
import crypto from 'crypto';
import config from '../config';
import { prisma } from '../config/prisma-client';
import { ApiError } from '../utils/errors';
import { generateAccessToken, generateRefreshToken } from '../services/token.service';
import { authMiddleware } from '../middleware/auth.middleware';
import { validateRequest } from '../middleware/validation.middleware';
import { z } from 'zod';
import {
  GoogleUrlRequestSchema,
  GoogleCallbackRequestSchema,
} from '../utils/api-types';

import {
  sensitiveAuthLimiter,
  generalAuthLimiter,
} from '../config/rate-limiter';

const router = Router();

const oAuth2Client = new OAuth2Client(
  config.google.clientId,
  config.google.clientSecret,
  `${config.frontendUrl}/google/callback`
);

/**
 * @swagger
 * tags:
 *   name: Authentication
 *   description: Google OAuth 2.0 (PKCE Flow) and token management
 */

/**
 * @swagger
 * /api/auth/google/url:
 *   get:
 *     summary: Get the Google OAuth authorization URL
 *     tags: [Authentication]
 *     description: |
 *       Generates and returns the full Google authorization URL.
 *       The frontend should redirect the user to this URL.
 *       This URL includes the necessary parameters for the PKCE flow, such as `code_challenge`.
 *       **Note:** The frontend is responsible for generating and storing the `code_verifier`.
 *     parameters:
 *       - in: query
 *         name: code_challenge
 *         required: true
 *         schema:
 *           type: string
 *         description: The code challenge generated by the frontend from the code verifier.
 *     responses:
 *       200:
 *         description: The full authorization URL.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 url:
 *                   type: string
 *                   description: The URL to redirect the user to for Google authentication.
 */
router.get('/google/url', generalAuthLimiter, validateRequest(z.object({ query: GoogleUrlRequestSchema })), (req, res) => {
    const { code_challenge } = req.query;

    if (!code_challenge || typeof code_challenge !== 'string') {
        throw new ApiError(400, 'code_challenge query parameter is required.');
    }

    const authorizeUrl = oAuth2Client.generateAuthUrl({
        access_type: 'offline', // Cần thiết để lấy refresh token
        scope: [
            'https://www.googleapis.com/auth/userinfo.profile',
            'https://www.googleapis.com/auth/userinfo.email',
        ],
        prompt: 'consent', // Yêu cầu người dùng đồng ý mỗi lần để đảm bảo nhận được refresh token
        code_challenge: code_challenge,
        code_challenge_method: CodeChallengeMethod.S256,
    });

    res.status(200).json({ url: authorizeUrl });
});


/**
 * @swagger
 * /api/auth/google/callback:
 *   post:
 *     summary: Handle Google OAuth callback with PKCE
 *     tags: [Authentication]
 *     description: |
 *       This endpoint is called by the frontend after being redirected back from Google.
 *       It receives the authorization `code` and the `codeVerifier` (which the frontend stored locally).
 *       The backend verifies these with Google, fetches user info, and establishes a session.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [code, codeVerifier]
 *             properties:
 *               code:
 *                 type: string
 *                 description: The authorization code from Google's redirect.
 *               codeVerifier:
 *                 type: string
 *                 description: The original code verifier stored by the frontend.
 *     responses:
 *       200:
 *         description: Authentication successful. User info is returned, and a refresh token is set in an HTTP-only cookie.
 *         headers:
 *           Set-Cookie:
 *             schema:
 *               type: string
 *               example: refreshToken=...; Path=/; HttpOnly; Secure; SameSite=Strict
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       400:
 *         description: Bad Request. `code` or `codeVerifier` is missing.
 *       401:
 *         description: Unauthorized. Invalid code/verifier or failed to authenticate with Google.
 */
router.post('/google/callback', sensitiveAuthLimiter, validateRequest(z.object({ body: GoogleCallbackRequestSchema })), async (req, res) => {
  const { code, codeVerifier } = req.body;
  if (!code) throw new ApiError(400, 'Authorization code is missing.');
  if (!codeVerifier) throw new ApiError(400, 'Code verifier is missing.');

  try {
    // 1. Dùng code và codeVerifier để lấy token từ Google
    const { tokens } = await oAuth2Client.getToken({
        code: code as string,
        codeVerifier: codeVerifier as string,
    });
    oAuth2Client.setCredentials(tokens);

    // 2. Dùng access token của Google để lấy thông tin người dùng
    const userInfoResponse = await oAuth2Client.request({
        url: 'https://www.googleapis.com/oauth2/v3/userinfo'
    });
    const googleUser = userInfoResponse.data as { sub: string; email: string; name: string; picture: string };

    // 3. Tìm hoặc tạo người dùng trong database của bạn (Upsert)
    const user = await prisma.user.upsert({
      where: { provider_providerId: { provider: 'google', providerId: googleUser.sub } },
      update: { name: googleUser.name, avatarUrl: googleUser.picture },
      create: {
        email: googleUser.email,
        name: googleUser.name,
        avatarUrl: googleUser.picture,
        provider: 'google',
        providerId: googleUser.sub,
      },
    });

    // 4. Tạo Refresh Token và gửi về client qua cookie
    const ipAddress = req.ip || 'unknown';
    const deviceInfo = req.headers['user-agent'] || 'unknown';
    const refreshToken = await generateRefreshToken(user.id, ipAddress, deviceInfo);

    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: config.node_env === 'production',
      sameSite: config.node_env === 'production' ? 'none' : 'strict', // secure true => sameSite none
      maxAge: config.jwt.refreshTokenExpiresInDays * 24 * 60 * 60 * 1000,
    });

    // 5. Trả về thông tin người dùng
    res.status(200).json({
      id: user.id,
      name: user.name,
      email: user.email,
      avatarUrl: user.avatarUrl,
    });
  } catch (error: any) {
    console.error('Google OAuth PKCE Error:', error.response?.data || error.message);
    throw new ApiError(401, 'Failed to authenticate with Google. The code may be invalid or expired.');
  }
});

/**
 * @swagger
 * /api/auth/refresh-token:
 *   post:
 *     summary: Obtain a new access token (sent via cookie)
 *     tags: [Authentication]
 *     description: |
 *       Uses the `refreshToken` from its cookie to issue a new, short-lived access token.
 *       The new access token is returned in a new `accessToken` HTTP-only cookie.
 *     responses:
 *       200:
 *         description: A new access token is successfully set in the cookie. The response body is empty.
 *         headers:
 *           Set-Cookie:
 *             schema:
 *               type: string
 *               example: accessToken=...; Path=/; HttpOnly; Secure; SameSite=Strict
 *       401:
 *         description: Unauthorized. Refresh token is missing.
 *       403:
 *         description: Forbidden. The refresh token is invalid, revoked, or expired.
 */
router.post('/refresh-token', sensitiveAuthLimiter, async (req, res) => {
  const refreshToken = req.cookies.refreshToken;
  if (!refreshToken) {
    throw new ApiError(401, 'Refresh token is missing.');
  }

  const hashedToken = crypto.createHash('sha256').update(refreshToken).digest('hex');

  const tokenInDb = await prisma.refreshToken.findUnique({
    where: { hashedToken },
    include: { user: true },
  });

  if (!tokenInDb || tokenInDb.revoked || new Date() > tokenInDb.expiresAt) {
    // Xóa cookie refreshToken không hợp lệ nếu có
    res.clearCookie('refreshToken');
    res.clearCookie('accessToken');
    throw new ApiError(403, 'Invalid or expired refresh token.');
  }

  const currentIpAddress = req.ip;
  if (tokenInDb.ipAddress !== currentIpAddress) {
    console.warn(
      `Potential refresh token theft detected for user ${tokenInDb.userId} from IP ${currentIpAddress}. Original IP was ${tokenInDb.ipAddress}.`
    );
    
    // HÀNH ĐỘNG BẢO MẬT: Thu hồi tất cả các token của người dùng này
    await prisma.refreshToken.updateMany({
      where: { userId: tokenInDb.userId, revoked: false },
      data: { revoked: true },
    });

    // res.clearCookie('refreshToken');
    // res.clearCookie('accessToken');
    throw new ApiError(403, 'Suspicious activity detected. Please log in again.');
  }
  
  const accessToken = generateAccessToken({ id: tokenInDb.userId });

  res.cookie('accessToken', accessToken, {
    httpOnly: true,
    secure: config.node_env === 'production',
    sameSite: 'strict',
    maxAge: 15 * 60 * 1000, // 15 phút (tính bằng mili-giây)
  });

  res.status(200).send();
});

/**
 * @swagger
 * /api/auth/logout:
 *   post:
 *     summary: Log out the user
 *     tags: [Authentication]
 *     description: |
 *       Logs the user out by revoking the current refresh token in the database and clearing the `refreshToken` cookie.
 *       This endpoint requires a valid Access Token for authorization to prevent CSRF attacks.
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully logged out.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Logged out successfully."
 *       401:
 *         description: Unauthorized. Missing or invalid access token.
 */
router.post('/logout', generalAuthLimiter, authMiddleware, async (req, res) => {
    const refreshToken = req.cookies.refreshToken;
    if (refreshToken) {
        const hashedToken = crypto.createHash('sha256').update(refreshToken).digest('hex');
        await prisma.refreshToken.update({
            where: { hashedToken },
            data: { revoked: true }
        }).catch(() => {}); // Bỏ qua lỗi nếu token không tồn tại
    }
    console.log(`User ${req.userId} logged out.`);

    res.clearCookie('refreshToken');
    res.clearCookie('accessToken');

    res.status(200).json({ message: 'Logged out successfully.' });
});

export const authRouter = router;